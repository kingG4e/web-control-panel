from flask import Blueprint, request, jsonify
from models.email import EmailDomain, EmailAccount, EmailForwarder, EmailAlias, db
from models.virtual_host import VirtualHost
from services.email_service import EmailService
from utils.auth import token_required
from datetime import datetime

email_bp = Blueprint('email', __name__)
email_service = EmailService()

@email_bp.route('/api/email/domains', methods=['GET'])
@token_required
def get_domains(current_user):
    """Get all Virtual Hosts as Email Domains for the current user"""
    try:
        # Get Virtual Hosts for the current user
        virtual_hosts = VirtualHost.query.filter_by(user_id=current_user.id).all()
        
        domains_data = []
        for vh in virtual_hosts:
            # Check if EmailDomain exists for this Virtual Host
            email_domain = EmailDomain.query.filter_by(domain=vh.domain).first()
            
            if not email_domain:
                # Create EmailDomain if it doesn't exist
                email_domain = EmailDomain(
                    domain=vh.domain,
                    virtual_host_id=vh.id,
                    status='active'
                )
                db.session.add(email_domain)
                db.session.flush()
            
            # Get domain data with accounts and forwarders
            domain_dict = email_domain.to_dict()
            domain_dict['virtual_host_id'] = vh.id
            domain_dict['linux_username'] = vh.linux_username
            domains_data.append(domain_dict)
        
        db.session.commit()
        return jsonify(domains_data)
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@email_bp.route('/api/email/domains/<int:id>', methods=['GET'])
@token_required
def get_domain(current_user, id):
    """Get specific Email Domain"""
    try:
        # Get Virtual Host first to check ownership
        virtual_host = VirtualHost.query.filter_by(id=id, user_id=current_user.id).first()
        if not virtual_host:
            return jsonify({'error': 'Virtual Host not found or access denied'}), 404
        
        # Get or create EmailDomain
        email_domain = EmailDomain.query.filter_by(domain=virtual_host.domain).first()
        if not email_domain:
            email_domain = EmailDomain(
                domain=virtual_host.domain,
                virtual_host_id=virtual_host.id,
                status='active'
        )
            db.session.add(email_domain)
        db.session.commit()
        
        domain_dict = email_domain.to_dict()
        domain_dict['virtual_host_id'] = virtual_host.id
        domain_dict['linux_username'] = virtual_host.linux_username
        return jsonify(domain_dict)
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@email_bp.route('/api/email/domains/<int:virtual_host_id>/accounts', methods=['POST'])
@token_required
def create_account(current_user, virtual_host_id):
    """Create email account for a Virtual Host domain"""
    try:
        # Verify Virtual Host ownership
        virtual_host = VirtualHost.query.filter_by(id=virtual_host_id, user_id=current_user.id).first()
        if not virtual_host:
            return jsonify({'error': 'Virtual Host not found or access denied'}), 404
        
        # Get or create EmailDomain
        email_domain = EmailDomain.query.filter_by(domain=virtual_host.domain).first()
        if not email_domain:
            email_domain = EmailDomain(
                domain=virtual_host.domain,
                virtual_host_id=virtual_host.id,
                status='active'
            )
            db.session.add(email_domain)
            db.session.flush()
        
    data = request.get_json()
    
    # Validate required fields
    required_fields = ['username', 'password']
    for field in required_fields:
        if field not in data:
            return jsonify({'error': f'Missing required field: {field}'}), 400
    
        # Check if account already exists
        existing_account = EmailAccount.query.filter_by(
            domain_id=email_domain.id, 
            username=data['username']
        ).first()
        if existing_account:
            return jsonify({'error': 'Email account already exists'}), 400
        
        # Create account in email system
        email_service.create_account(
            data['username'],
            virtual_host.domain,
            data['password'],
            quota=data.get('quota', 1024)
        )
        
        # Create account record
        account = EmailAccount(
            domain_id=email_domain.id,
            username=data['username'],
            password=data['password'],  # Note: In production, encrypt this
            quota=data.get('quota', 1024)
        )
        
        db.session.add(account)
        db.session.commit()
        
        return jsonify(account.to_dict()), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@email_bp.route('/api/email/domains/<int:virtual_host_id>/forwarders', methods=['POST'])
@token_required
def create_forwarder(current_user, virtual_host_id):
    """Create email forwarder for a Virtual Host domain"""
    try:
        # Verify Virtual Host ownership
        virtual_host = VirtualHost.query.filter_by(id=virtual_host_id, user_id=current_user.id).first()
        if not virtual_host:
            return jsonify({'error': 'Virtual Host not found or access denied'}), 404
        
        # Get or create EmailDomain
        email_domain = EmailDomain.query.filter_by(domain=virtual_host.domain).first()
        if not email_domain:
            email_domain = EmailDomain(
                domain=virtual_host.domain,
                virtual_host_id=virtual_host.id,
                status='active'
            )
            db.session.add(email_domain)
            db.session.flush()
        
    data = request.get_json()
    
    # Validate required fields
    required_fields = ['source', 'destination']
    for field in required_fields:
        if field not in data:
            return jsonify({'error': f'Missing required field: {field}'}), 400
    
        # Check if forwarder already exists
        existing_forwarder = EmailForwarder.query.filter_by(
            domain_id=email_domain.id, 
            source=data['source']
        ).first()
        if existing_forwarder:
            return jsonify({'error': 'Email forwarder already exists'}), 400
        
        # Create forwarder in email system
        email_service.create_forwarder(
            data['source'],
            data['destination'],
            virtual_host.domain
        )
        
        # Create forwarder record
        forwarder = EmailForwarder(
            domain_id=email_domain.id,
            source=data['source'],
            destination=data['destination']
        )
        
        db.session.add(forwarder)
        db.session.commit()
        
        return jsonify(forwarder.to_dict()), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@email_bp.route('/api/email/accounts/<int:id>/aliases', methods=['POST'])
@token_required
def create_alias(current_user, id):
    """Create email alias"""
    try:
    account = EmailAccount.query.get_or_404(id)
        
        # Verify ownership through Virtual Host
        email_domain = account.email_domain
        virtual_host = VirtualHost.query.filter_by(domain=email_domain.domain, user_id=current_user.id).first()
        if not virtual_host:
            return jsonify({'error': 'Access denied'}), 403
        
    data = request.get_json()
    
    # Validate required fields
    if 'alias' not in data:
        return jsonify({'error': 'Missing required field: alias'}), 400
    
        # Create alias in email system
        email_service.create_alias(
            data['alias'],
            account.get_email()
        )
        
        # Create alias record
        alias = EmailAlias(
            account_id=account.id,
            alias=data['alias']
        )
        
        db.session.add(alias)
        db.session.commit()
        
        return jsonify(alias.to_dict()), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@email_bp.route('/api/email/accounts/<int:id>', methods=['PUT'])
@token_required
def update_account(current_user, id):
    """Update email account"""
    try:
        account = EmailAccount.query.get_or_404(id)
    
        # Verify ownership through Virtual Host
        email_domain = account.email_domain
        virtual_host = VirtualHost.query.filter_by(domain=email_domain.domain, user_id=current_user.id).first()
        if not virtual_host:
            return jsonify({'error': 'Access denied'}), 403
        
        data = request.get_json()
        
        # Update password if provided
        if 'password' in data and data['password']:
            email_service.update_account_password(
                account.username, 
                email_domain.domain, 
                data['password']
            )
            account.password = data['password']
        
        # Update quota if provided
        if 'quota' in data:
            email_service.update_account_quota(
                account.username, 
                email_domain.domain, 
                data['quota']
            )
            account.quota = data['quota']
        
        account.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify(account.to_dict())
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@email_bp.route('/api/email/accounts/<int:id>', methods=['DELETE'])
@token_required
def delete_account(current_user, id):
    """Delete email account"""
    try:
    account = EmailAccount.query.get_or_404(id)
        
        # Verify ownership through Virtual Host
        email_domain = account.email_domain
        virtual_host = VirtualHost.query.filter_by(domain=email_domain.domain, user_id=current_user.id).first()
        if not virtual_host:
            return jsonify({'error': 'Access denied'}), 403
        
        # Delete account from email system
        email_service.delete_account(account.username, email_domain.domain)
        
        # Delete from our database
        db.session.delete(account)
        db.session.commit()
        
        return '', 204
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@email_bp.route('/api/email/forwarders/<int:id>', methods=['DELETE'])
@token_required
def delete_forwarder(current_user, id):
    """Delete email forwarder"""
    try:
    forwarder = EmailForwarder.query.get_or_404(id)
        
        # Verify ownership through Virtual Host
        email_domain = forwarder.email_domain
        virtual_host = VirtualHost.query.filter_by(domain=email_domain.domain, user_id=current_user.id).first()
        if not virtual_host:
            return jsonify({'error': 'Access denied'}), 403
        
        # Delete forwarder from email system
        email_service.delete_forwarder(forwarder.source, email_domain.domain)
        
        # Delete from our database
        db.session.delete(forwarder)
        db.session.commit()
        
        return '', 204
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@email_bp.route('/api/email/aliases/<int:id>', methods=['DELETE'])
@token_required
def delete_alias(current_user, id):
    """Delete email alias"""
    try:
    alias = EmailAlias.query.get_or_404(id)
    
        # Verify ownership through Virtual Host
        account = EmailAccount.query.get_or_404(alias.account_id)
        email_domain = account.email_domain
        virtual_host = VirtualHost.query.filter_by(domain=email_domain.domain, user_id=current_user.id).first()
        if not virtual_host:
            return jsonify({'error': 'Access denied'}), 403
        
        # Delete alias from email system
        email_service.delete_alias(alias.alias)
        
        # Delete from our database
        db.session.delete(alias)
        db.session.commit()
        
        return '', 204
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@email_bp.route('/api/email/accounts/<int:id>/quota', methods=['GET'])
@token_required
def get_quota_usage(current_user, id):
    """Get quota usage for email account"""
    try:
    account = EmailAccount.query.get_or_404(id)
        
        # Verify ownership through Virtual Host
        email_domain = account.email_domain
        virtual_host = VirtualHost.query.filter_by(domain=email_domain.domain, user_id=current_user.id).first()
        if not virtual_host:
            return jsonify({'error': 'Access denied'}), 403
        
        # Get quota usage from filesystem
        used_quota = email_service.get_quota_usage(account.username, email_domain.domain)
        
        # Update account record
        account.used_quota = used_quota
        db.session.commit()
        
        return jsonify({
            'quota': account.quota,
            'used_quota': used_quota,
            'available_quota': account.quota - used_quota
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500 